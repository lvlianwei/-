
 
 1 mediaPlayList 文件的作用逻辑。
	作用：	
		Manage the info of GMMediaPlaylist.
		主要是维护几个list列表。通过操作这几个list。实现对播放曲目的控制。
 2 运算符重载。
	在GMMediaPlayList.h文件中的playlistInfol内部类中使用了= /==运算符的重载

 3 友元类使用复习
	友元函数：对于外部的私有的类或者方法，在其他类中无访问权限，但是可以在类中声明友元函数或者友元类来访问类中的私有成员。友元是一种特权访问其他私有对像、函数的方式。

	1 全局函数做友元函数
		全局函数中可以访问类中的私有成员
		
	2 局部函数做友元函数
		该类中的局部函数可以访问另一个类中的私有成员。
	3 友元类
		如果这个类被声明为友元类，则这个类中的所有方法，都可以访问其他类的私有成员。
 
 4 random_shuffle (begin,end)
		c++STL内部函数。
		通过random下的random_shuffle()方法，将begin-end范围内的数据重置。
		
5 在usbService的处理逻辑中维护了三个vector.origin和random还有infoList。其中random表中存储的是什么？是origin的index还是fid。infoList和origin和random有什么关系。

	  m_origin.push_back(itemSp);
      m_random.push_back(itemSp);  
	 在vector 和 origin列表中存储的是item实体对象。在selectList方法中，实现了将DB中取到的数据存放在list的逻辑。
	 
	 在infoList 中存放的是PlayItemlist实体。 6 c++ 中内部类 以及内部类和友元类的区别
	 
6  c++ 中内部类 以及内部类和友元类的区别 	
	内部类可以有权限，当定义为private时，外部类不可以访问内部类的成员，但是内部类可以通过类对象的方式访问外部类
	内部类是外部类的友元类，即内部类可以访问外部类的所有成员。
	但是外部类没有办法访问内部类的私有成员，且访问普通成员得通过实例化对象的方式。

7 usbService中的next方法的核心逻辑总结   --------延期（10/21）
		usbService的next的核心逻辑在GMMediaPlaylist文件中的next方法中实现
		方法参数：
			step:next的步数
			forceSequence：默认播放模式下为false。
		执行过程：
			默认播放模式下（repeatAll/random OFF）,在next方法中，顺序播放状态下，将originIndex的值+step后，与originList的size比较。
				如果大于了size，则说明需要从头开始计算播放位置。
				如果不大于size，则将originIndex的值加step
			在强制顺序播放模式下，需要将randomIndex值设置为当前播放的item的index.
			repeatALl或者one时，需要修正listInfo的索引。同时 还要更新playlistInfo
			最后调用回调类m_call类中的onPlayItemChanged方法，将信息反馈给调用方。
		最终在onPlayItemChanged方法中及之后执行的逻辑暂时还未解析。
		
8 运算符重载。
	在GMMediaPlayList.h文件中的playlistInfol内部类中使用了= /==运算符的重载
	在自定义的类或者结构体中，不能像基础类型那样可以直接使用等号赋值或者使用==判断两者是否相同。因为自定义的类中的一些成员涉及到引用类型。开辟空间在堆中，没法直接通过=赋值。
	这时，就需要重载=、==运算符来实现运算符的重载。
	
	
	

			

		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
 
 

	
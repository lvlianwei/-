

1 c和c++中const的区别

	在c中，不分配内存，只读变量默认外部链接
	c++中，const不分配内存。
		默认内部链接（其他标识符默认外部链接）
		定义为extern时分配内存
		取const变量的地址时分配内存
	异同：
		const 修饰全局变量
			c中，全局const存放在只读数据段。不可修改
			c++中，const修饰的变量被extern修饰或者被取地址时，该变量放在只读数据段，不可修改（哪怕指针也不行）
		const修饰局部变量
			c中，const修饰的局部变量，放在堆区，理论上不可修改，但可以通过指针的方式修改
			c++：
				a.局部变量为基础数据类型，编译器将该局部变量放在符号表中，不分配内存。
					对其取地址，分配内存，可通过指针修改。	
				b.局部变量为基础数据类型，一个变量初始化了这个局部变量，const int a=b; 数据a分配内存
				
				c.自定义数据类型，分配内存，可以通过指针的方式修改对象中的值。
2 指针引用问题
	给指针起了一个别名。
	int *a;
	int *&b=a;

3 c++中的内联函数问题
	在编译阶段将代码插入到调用位置，节省调用时间，但是增大了程序的体积。


4 函数重载原理


5 malloc函数
	原型：void * malloc(int size )
	表示向系统申请分配指定字节size的空间，返回值为void*,void *可以强制转换为任何类型的指针。
	
6 宏相关问题
	

7 友元函数 

8 运算符重载

9 在继承中，父类中的同名函数被子类重写后，会出现父类中的函数被隐藏的问题。这时通过类名限定符可以访问吗


10 const和#define的区别
	宏没有类型，const有类型
	宏常量不重视作用域（默认从定义处到尾部。遇到#undef结束），const有作用域
	
	注意：宏常量不能有命令空间。
	
11 如何避免“野指针”
野指针”产生原因及解决办法如下：
	（1）指针变量声明时没有被初始化。解决办法：指针声明时初始化，可以是具体的地址值，也可让它指向NULL。
	（2）指针 p 被 free 或者 delete 之后，没有置为 NULL。解决办法：指针指向的内存空间被释放后指针应该指向NULL。
	（3）指针操作超越了变量的作用范围。解决办法：在变量的作用域结束前释放掉变量的地址空间并且让指针指向NULL。


12 变量的声明和定义有什么区别
	为变量分配地址和存储空间的称为定义，不分配地址的称为声明。一个变量可以在多个地方声明，但只能在一个地方定义。
	加入extern修饰的是变量的声明，说明此变量将在文件以外或在文件后面部分定义。
	说明：很多时候一个变量，只是声明，不分配内存空间，知道具体使用时才初始化，分配内存空间，如外部变量。

13 Sizeof和strlen的区别
	sizeof是一个操作符，strlen是库函数。
	sizeof的参数可以是数据的类型，也可以是变量，而strlen只能以结尾为‘\0‘的字符串作参数。
	编译器在编译时就计算出了sizeof的结果。而strlen函数必须在运行时才能计算出来。并且sizeof计算的是数据类型占内存的大小，
	而strlen计算的是字符串实际的长度。
	数组做sizeof的参数不退化，传递给strlen就退化为指针了。
	注意：有些是操作符看起来像是函数，而有些函数名看起来又像操作符，这类容易混淆的名称一定要加以区分，否则遇到数组名这类特殊数据类型作
	参数时就很容易出错。最容易混淆为函数的操作符就是sizeof。
	说明：指针是一种普通的变量，从访问上没有什么不同于其他变量的特性。其保存的数值是个整型数据，和整型变量不同的是，
	这个整型数据指向的是一段内存地址。
	
	
14 set_new_handler
	set_new_handler函数的作用是设置new_p指向的函数为new操作或new[]操作失败时调用的处理函数。

 
 
 1 模版
 
	c++有两种模版机制
		函数模版
		类模版
	模版用于表达逻辑结构相同，但是具体数据类型不同的数据对象的通用行为。
	
	
	函数模版
		实现泛型，增强函数的通用性
		
		写法
			template<class T>
			Void MySwap(T& a,T & b){
				T temp = a;
				a = b;
				b = temp;

			}
		函数模版可以自动推倒参数的类型，也可以显示指定
			MySwap<int>(1,2);---显示指定
			MySwap(a,b);---自动推倒
		
		模版函数与普通函数的区别
			模版函数不允许自动类型转换
			普通函数能够自动类型转换。
			eg: int a=1;
				char b='a';
				MyAdd(a,b);
				普通函数会将a转为char类型，然后进行相加。
				模版函数不可以
		
		模版函数与普通函数同时存在时的调用规则
			优先考虑普通函数
			可以通过模版实参类表限定编译器只调用模版函数  MySwap<> (a,b);
			模版函数也可以重载
			普通函数和模版函数同时存在时，模版可以产生一个更好的匹配，则优先调用模版。
			
		模版函数的实现机制
			函数模版通过不同类型，产生不同类型的函数，编译器会对函数模版进行两次编译，
			声明的地方对模版函数进行编译，在调用的地方对参数进行替换然后进行二次编译
			
		模版函数的局限性
			对于一些复杂类型，例如数组，实体类。在进行匹配时可能不能达到我们理想的结果。
			这时，通过具体化来解决这一问题。
		
		常规模版、具体化模版、非模版函数（普通函数）的调用顺序
			非模板函数（普通函数）> 具体化模板函数 > 常规模板
			模版函数具体化：具体化表示为某一特定的类型重写函数模板，声明的含义是使用独立的，专门的函数定义显示地为 特定类型生成函数定义。
			常规模版
				template <class T>
				void mySwap(T &a,T &b)
				{
					T temp = a;
					a = b; 
					b = temp;
				}
				
			具体化模版：
				template<>void mySwap<Person>(Person &p1, Person &p2)

			
	
	类模版	
	
		概念
			多个类功能相同，但是数据类型不同。
			类模板不能进行类型自动推导 
			类模版实现类所需数据类型的参数化
		
		类模板用于实现类所需数据的类型参数化
		
		类模板做函数参数
		
		类模版派生普通类
			子类在实例化时，必须知道父类的具体类型，这样才能确定子类分配多少内存。
		
		类模版派生类模版
			继承类模板的时候，必须要确定基类的大小
		
		类模版类内实现
			类内实现，就是在模板类中实现具体的函数
			
		类模版类外实现
		
			
 2 C++类型转换
		原则：尽量少做类型转换，除了用来解决特殊问题。
			
		静态类型转换(static_cast)
			用于类结构中，基类和子类之间指针或者引用的转换
				Base * base=NULL;
				Son * son=NULL;
				向上类型转换
					父类的指针或者引用指向子类的对象。 安全的
					Base * base2=static_cast<Base *>(son);
					
				向下类型转换
					子类的指针或者引用指向父类的对象。 不安全的。没有动态类型检查
					Son * son2=static_cast<Son *> (base);
				
				向上向下类型转换存在于继承关系的类中，对于没有继承关系的类之间，不存在静态类型转换问题
					
			用于基础数据类型之间的转换
				这种转换的安全性需要开发人员的保证。
				int char 之间的转换
					int a=3;
					char b=static_cast<char> (a);
					
			
		动态类型转换（dynamic_cast）
			主要用于类结构中父子类之间的上下 类型转换	
				Base *base=NULL;
				Son * son=NULL;
				在向上类型转换时，与静态转换一样
					Base * base2=dynamic_cast<Base *>(son);
				在向下类型转换时，dynamic_cast会做类型检查，比static_cast安全,动态类型转换时，不允许向下转换
					Son * son2=dynamic_cast<Son * >(base);------报错
					
				向上向下类型转换存在于继承关系的类中，对于没有继承关系的类之间，不存在静态类型转换问题
				
			动态类型转换不支持基础数据类型
			
			
		常量转换(const_cast)
			主要用来完成常量指针或者常量引用与普通指针和普通引用之间的转换
				常量指针通过const_cast转换后，可以变为普通指针，但是依旧指向原来的对象。
				引用也同理
					常量指针。
					const int * p=NULL;//一个常量指针
					int * np=const_cast<int *> (p);//将一个常见指针转为普通指针
					
					int * point=NULL;
					const int* nPoint=const_cast<const int *>(point);//将一个普通指针转为常量指针
					--------------------------
					常量引用
					int num = 10;
					int & refNum = num;
					const int& refNum2 = const_cast<const int&>(refNum);

				
			注意
				const_cast不能用于非指针非引用的其他常量类型的转换。
				const int a;
				int na=const_cast<int> a;//不允许。。。。
		
			
		重新解释转换(reinterpret_cast)	
			最不安全的一种转换机制
			用于将一种数据类型从一种类型转换为另一种类型。它可以将一个指针转换成一个整数，也可以将一个整数转换成一个指针
			不建议使用。。慎用慎用。。。
			
			
			
 3 c++异常
		概念
			异常处理的思想，问题检测和问题处理分离。问题检测检测到问题后，抛出一个对象给问题处理代码。
			这个对象中包含了错误内容等信息，是两段代码的桥梁。
			
		语法
			throw 0;
			try{}
			catch(){}
			有异常通过throw操作创建一个异常对象并抛出
			可以将代码块放在try中，try引起异常时，会终止执行，到catch中按照先后顺序匹配异常类型，处理或者继续抛出
			处理不了的异常，在catch的最后一个分支 ，会使用throw向上抛出。
			
		异常严格类型匹配
			异常有自己的类型，比如说int型的异常，char型的异常，c++中有严格的异常匹配。
			在catch中 如果没有可以匹配到的异常，可以在最后定义一个其他类型异常。
				catch（...）//其他异常类
				{
					//处理过程
				}
			
			catch的匹配过程是找最先匹配的，不是最佳匹配。
		栈解旋(unwinding)	
			异常抛出后，在进入try起到异常被抛出前，栈上的构造的所有对象都会自动析构，称为栈解旋
			
			
		异常接口声明
			为了增加代码可读性，在函数声明处可以定义可能异常抛出的类型。
				void function() throw(A，B，C)---该函数只能抛出ABC这三种异常或者子异常。
			
			函数声明处没有包含异常接口，则该函数可以抛出任何类型异常。
				void function();
			
			不允许函数抛出任何异常。
				void function()throw()
			
			函数抛出了不允许的异常，系统会自动调用unexpected函数，该函数的默认行为时调用terminate函数终止程序
			
		异常变量生命周期	
			
				throw的异常是有类型的，可以是数字、字符串、类对象。
				throw的异常是有类型的，catch需严格匹配异常类型。

		异常的多态使用	
			在异常类中，可以使用多态来实现多种不同的异常。
			
			
		C++标准异常库
		
			C++标准异常库中提供了很多异常类，通过继承关系组织起来。
			每个类都有提供了构造函数、复制构造函数、和赋值操作符重载
			logic_error类及其子类、runtime_error类及其子类，它们的构造函数是接受一个string类型的形式参数，用于异常信息的描述
			所有的异常类都有一个what()方法，返回const char* 类型（C风格字符串）的值，描述异常信息。
			
			具体每个异常类的作用，参考文档或者手册。
			
			编写自己的异常类
				建议继承标准异常类中的父类exception
				重载父类的what函数和虚析构函数。
				因为栈展开的过程中，要复制异常类型，那么要根据你在类中添加的成员考虑是否提供自己的复制构造函数。
					比如你自定义的异常中有string，char[]这种类型时，就需要提供复制构造函数
			
			
			
 4 输入输出流
		c++输入输出包括三个部分
			从系统的指定设备的输入输出，键盘，鼠标，显示器等，这种输入输出称为标准输入输出，标准I/O
			以磁盘文件为对象进行输入输出，称为文件的输入输出，简称文件I/O
			对内存的指定空间进行输入输出。指定一个字符数组作为存储空间，称为字符串输入输出，串I/O
			
			
			
			
			
			
			
			
			
			
			
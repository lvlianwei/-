

1 c和c++中const的区别

	在c中，不分配内存，只读变量默认外部链接
	c++中，const不分配内存。
		默认内部链接（其他标识符默认外部链接）
		定义为extern时分配内存
		取const变量的地址时分配内存
	异同：
		const 修饰全局变量
			c中，全局const存放在只读数据段。不可修改
			c++中，const修饰的变量被extern修饰或者被取地址时，该变量放在只读数据段，不可修改（哪怕指针也不行）
		const修饰局部变量
			c中，const修饰的局部变量，放在堆区，理论上不可修改，但可以通过指针的方式修改
			c++：
				a.局部变量为基础数据类型，编译器将该局部变量放在符号表中，不分配内存。
					对其取地址，分配内存，可通过指针修改。	
				b.局部变量为基础数据类型，一个变量初始化了这个局部变量，const int a=b; 数据a分配内存
				
				c.自定义数据类型，分配内存，可以通过指针的方式修改对象中的值。
2 指针引用问题
	给指针起了一个别名。
	int *a;
	int *&b=a;

3 c++中的内联函数问题
	在编译阶段将代码插入到调用位置，节省调用时间，但是增大了程序的体积。


4 函数重载原理


5 malloc函数
	原型：void * malloc(int size )
	表示向系统申请分配指定字节size的空间，返回值为void*,void *可以强制转换为任何类型的指针。
	
6 宏相关问题
	

7 友元函数 

8 运算符重载

9 在继承中，父类中的同名函数被子类重写后，会出现父类中的函数被隐藏的问题。这时通过类名限定符可以访问吗


10 const和#define的区别
	宏没有类型，const有类型
	宏常量不重视作用域（默认从定义处到尾部。遇到#undef结束），const有作用域
	
	注意：宏常量不能有命令空间。
	
11 如何避免“野指针”
野指针”产生原因及解决办法如下：
	（1）指针变量声明时没有被初始化。解决办法：指针声明时初始化，可以是具体的地址值，也可让它指向NULL。
	（2）指针 p 被 free 或者 delete 之后，没有置为 NULL。解决办法：指针指向的内存空间被释放后指针应该指向NULL。
	（3）指针操作超越了变量的作用范围。解决办法：在变量的作用域结束前释放掉变量的地址空间并且让指针指向NULL。


12 变量的声明和定义有什么区别
	为变量分配地址和存储空间的称为定义，不分配地址的称为声明。一个变量可以在多个地方声明，但只能在一个地方定义。
	加入extern修饰的是变量的声明，说明此变量将在文件以外或在文件后面部分定义。
	说明：很多时候一个变量，只是声明，不分配内存空间，知道具体使用时才初始化，分配内存空间，如外部变量。

13 Sizeof和strlen的区别
	sizeof是一个操作符，strlen是库函数。
	sizeof的参数可以是数据的类型，也可以是变量，而strlen只能以结尾为‘\0‘的字符串作参数。
	编译器在编译时就计算出了sizeof的结果。而strlen函数必须在运行时才能计算出来。并且sizeof计算的是数据类型占内存的大小，
	而strlen计算的是字符串实际的长度。
	数组做sizeof的参数不退化，传递给strlen就退化为指针了。
	注意：有些是操作符看起来像是函数，而有些函数名看起来又像操作符，这类容易混淆的名称一定要加以区分，否则遇到数组名这类特殊数据类型作
	参数时就很容易出错。最容易混淆为函数的操作符就是sizeof。
	说明：指针是一种普通的变量，从访问上没有什么不同于其他变量的特性。其保存的数值是个整型数据，和整型变量不同的是，
	这个整型数据指向的是一段内存地址。
	
	
14 set_new_handler
	set_new_handler函数的作用是设置new_p指向的函数为new操作或new[]操作失败时调用的处理函数。
	
15 (.text+0x20)：对‘main’未定义的引用 问题
	解决：
		1 检出main函数写的是否有问题
		2 检查makefile文件写的是否有问题，
		一般这个问题的出现多数是makefile文件写的问题。


===============读《c++从入门到放弃》一书问题整理
1  在 c++中main函数的参数什么意义？
	int main (int argc,char * argv[]);
	两个参数中第一个参数argc表示在Dos命令行中的输入的程序名和参数个数之和，第二个参数中argv[0]记录的程序名，后面的argv[i]记录的输入参数。
		
2  c++中预编译指令什么意思？
	预编译是指在程序代码编译之前对代码的一些处理。
	预处理器的主要作用就是把通过预处理的内建功能对一个资源进行等价替换，最常见的预处理有：文件包含，条件编译、布局控制和宏替换4种

3  c++或者c语言中，怎么制作成动态、静态库让其他程序使用？

4  c/C++程序从代码到可执行程序经历的过程
	预处理，编译，汇编，链接

5  #include <iostream>  iostream从哪里来 
	https://blog.csdn.net/qq_15041569/article/details/91358831
	C++编译环境中包含了c++标准库，c++标准库中也包含了iostream
	

6  cout<< "hello word " cout 是哪里来的函数
	在c++安装编译环境时（g++）,同时也安装了c++标准库，标准库中有标准输入输出函数，就是cout/cin

7  c++中的数据类型中的构造类型中枚举类型、公共体类型、指针类型详细了解
	枚举类型 enum 
		enum myEum｛a,b,c,d｝
		默认值：从零依次递增。。枚举类型可以声明特定的选项的值，没有声明的顺着前面一次递增
		整数值不可以直接赋值给枚举类型变量，如果真的需要用整数，需要强制类型转换

	公共体类型
		 union 共用体类型名
             {
                 成员列表
             };
		结构体变量所占内存长度是各个成员的内存长度之和，每个成员都有其自己的内存单元。共用体变量所占的内存长度等于最长的成员的长度。
		.对共同体变量的访问方式。
		不能引用共同体变量，而只能引用共同体变量中的成员。下面的引用方式是正确的：
		（1）a.i       (引用共同体变量中的整型成员i)
		（2）a.ch     (引用共同体变量中的字符型成员ch)
		（3）a.f       (引用共同体变量中的双精度类型成员
		不能引用共同体变量，例如cout<<a;是不对的，应写成cout<<a.i;或者cout<<a.ch;
	
	指针类型：
		暂无。。。
		
8  c++中长短整形的范围 int  usigned int long int

9 文件包含：#include <io.h>和"io.h"的区别
	他们唯一的区别就是搜索路径不同：
　　对于#include <io.h> ，编译器从标准库路径开始搜索
　　对于#include "io.h" ，编译器从用户的工作路径开始搜索



10 C++中sizeof(待深入理解)
	学习地址：
		https://www.cnblogs.com/huolong-blog/p/7587711.html
	sizeof是一个操作符（operator）。
	其作用是返回一个对象或类型所占的内存字节数。
	
	三种表达形式
		 siezeof(int) 
		 sizeof(3)
		 sizeof 3
		 
	基本数据类型的sizeof(int logn short ...)简单内置数据类型的内存大小和系统有关
	 
	结构体的sizeof	 
		结构体的sizeof涉及到字节对齐问题。这里暂不深究。
		空结构体（不含数据成员）的sizeof值为1
	
	数组的sizeof
		数组的sizeof值等于数组所占用的内存字节数。
		当字符数组表示字符串时，其sizeof值将’/0’计算进去。
		当数组为形参时，其sizeof值相当于指针的sizeof值。 
	
	指针的sizeof
		指针是用来记录另一个对象的地址，所以指针的内存大小当然就等于计算机内部地址总线的宽度。
		在32位计算机中，一个指针变量的返回值必定是4。
		指针变量的sizeof值与指针所指的对象没有任何关系。


	函数的sizeof
		sizeof也可对一个函数调用求值，其结果是函数返回值类型的大小，函数并不会被调用。
		对函数求值的形式：sizeof(函数名(实参表))
			1）不可以对返回值类型为空的函数求值。 
            2）不可以对函数名求值。
            3）对有参数的函数，在用sizeof时，须写上实参表。
















1 类和对象

	封装
		将属性和行为合在一起封装在一个类中
		对变量和函数进行访问控制
	访问权限
		public 
		private
		protected
	struct 和class的区别
		  class默认访问权限为private,struct默认访问权限为public.
		  
	
	类的构造和析构
		构造和析构两个函数被编译器自动调用，完成对象的初始化和对象清理工作
		构造函数主要创建对象时对对象的属性进行赋值，自动调用
		析构函数主要是对象销毁前系统自动调用。清理工作
		构造函数语法
			ClassName() ---无返回值，无void,可有参数，可重载
		析构语法
			~ClassName()---无返回值，无void,无参数，不可重载
			
		构造分类
			按参数分
				有参构造
				无参构造
			按类型分类
				普通构造函数
				拷贝构造函数
		
		构造调用
			无参构造
				Person person;
				Person person();----错误调用方式
				
			有参构造
				括号法
					Person person（100）;
					Person person2(person1);---调用拷贝构造
				匿名对象的方式
					Person（200）；
					Person person3=Person(300);//匿名对象方式，相当于Person person3(Person(300));
				=号法（隐式转换）
					Person person4=400;
					person person5=person4; ---调用拷贝构造
					
		注意:不能调用拷贝构造函数去初始化匿名对象
				
		
			拷贝构造调用时机
				旧对象初始化新的对象
				
				传递的参数是普通对象，函数参数也是普通对象，传递将会调用拷贝构造
				
				 函数返回局部对象
				 
		c++中构造函数的调用规则
			默认情况下，编译器会增加三个构造函数
				默认构造函数（无参，函数体为空）
				默认析构函数 （无参，函数体为空）
				默认拷贝构造函数，对类中非静态成员属性简单值拷贝
			自定义拷贝构造时，不提供任何构造函数
			自定义了普通构造时（非拷贝），C++不提供默认无参构造，但会提供默认拷贝构造。
		
		深浅拷贝问题
			浅拷贝：同一类型的对象，通过浅拷贝实现复制，但是如果对象中存在有指向堆区的指针。就会出现问题。
			
			深拷贝：类中有指针，并且指针有动态分配空间，析构函数做释放处理，这时，需要自定义拷贝构造函数，自行给动态指针分配空间。
			class Person{
			public:
				Person(char* name,int age){
					pName = (char*)malloc(strlen(name) + 1);
					strcpy(pName,name);
					mAge = age;
				}
				//增加拷贝构造函数
				Person(const Person& person){
					pName = (char*)malloc(strlen(person.pName) + 1);
					strcpy(pName, person.pName);
					mAge = person.mAge;
				}
				~Person(){
					if (pName != NULL){
						free(pName);
					}
				}
			private:
				char* pName;
				int mAge;
			};
			void test(){
				Person p1("Edward",30);
				//用对象p1初始化对象p2,调用c++提供的默认拷贝构造函数
				Person p2 = p1;

		
		初始化列表
			Person(int a, int b, int c):mA(a),mB(b),mC(c){}
			只可以在构造函数中使用
		
		类对象作为成员
			构造函数初始化列表
				在类作为成员时，在该类就行初始化时，需要对成员也就行初始化，这时，c++提供了构成函数初始化列表
				在构造函数的参数列表中，要提供成员对象初始化的参数
				Person(string carName, string tracName, string name) : mTractor(tracName), mCar(carName), mName(name){
					cout << "Person 构造函数!" << endl;
				}
			在调用各自的构造函数时，根据在类中定义顺序，依次调用他们的构造函数，先调用成员的，再调用自身的。
			析构和构造的顺序相反，先自身，再成员
		
		explicit关键字
			禁止通过构造函数进行的隐式转换
			
		
		c++中创建对象
			先为对象分配一块内存
			再调用构造函数初始化那块内存
		
		
		C++ 中动态分配内存
			创建对象的操作封装在了new运算符中，
			Person * person =new Person; ---new Person 返回一个指针
			delete 释放内存，先调用析构函数，再释放。
				delete只适用与new
			在删除指针后，立刻给他赋值为NULL.
			
			
		数组上使用new和delete
			创建数组：char　* pStr=new char[100];
			删除数组：delete[] pStr;
		
		创建对象数组问题
			创建对象数组，必须对数组中的每个对像调用构造函数
			
		delete void*可能会出错
		
		在删除数组时一定要注意：	
			new了一个数组，delete时一定要delete[] 
			new 了一个单个实体，detele不要delete[]
		
	
	静态成员
		类中的成员（变量或者函数）可以用static声明为静态的，称为静态成员
		不论创建多少对象，只有一份静态成员，被各个对象共享。
		
		静态成员变量
			在编译时分配内存。
			必须在类内声明，类外定义初始化，初始化时不加static---必须初始化
			不属于某个对象，分配空间时不算静态成员的空间
			可以通过类名或对象名引用
			静态成员也有访问权限
				
		静态成员函数
			在编译阶段分配内存
			通过类名或者对象名调用
			可以访问静态成员变量，不能访问普通成员变量
			其作用主要是管理静态成员变量
			有权限
			普通函数可以访问静态变量、静态函数
			
			
		const 静态成员
			const static int age=20;----定义静态const数据成员时，最好在类内部初始化
			即可共享，又不可变
		
		
	c++中成员变量和函数的存储
		普通变量：存储在类中。准确的说存储在类对象开辟的内存上
		成员函数只有一份函数实例。不存在类对象中，而是存在公共区域，让每个对象都可以用它。
		静态函数、静态成员不存在对象中。
		c++中变量和函数的存储是分开的。
	
	this指针
		隐含在成员函数内，自动生成，用来保存该对象的地址。
		指向对象的指针。
		所有对象公用同一函数。this指针用来区分哪个对象调用了该函数。
		非静态函数中，都有一个this指针，静态函数中无this指针，所以没法访问非静态变量
		
		用处
			当形参和实参命名相同时，通过this来区分
			非静态函数返回值为自身的对象，用* this
		
		
	const修饰成员函数
		const 修饰成员函数时，该成员函数不可以修改任何类中的普通变量。 void test（）const {...}
		成员变量类型符前用mutable修饰时例外。
	
	const修饰对象(常对象)
		常对象只能调用const的成员函数
		常对象可访问 const 或非 const 数据成员，不能修改，除非成员用mutable修饰
	
	友元
		特点：
			友元不可以被继承	
			友元关系是单向的
			不具有传递性
		优点：
			在实现类之间数据共享时，减少系统开销，提高效率
		缺点：友元函数破环了封装机制，尽量使用成员函数，除非不得已的情况下才使用友元函数。
		
		使用友元的场景：
			1)运算符重载的某些场合需要使用友元。
			2)两个类要共享数据的时候
		使用方法：
			友元函数的参数：
			   因为友元函数没有this指针，则参数要有三种情况：
			   1、 要访问非static成员时，需要对象做参数；--常用(友元函数常含有参数)
			   2、 要访问static成员或全局变量时，则不需要对象做参数
			   3、 如果做参数的对象是全局对象，则不需要对象做参数
			友元函数的位置：
				因为友元函数是类外的函数，所以它的声明可以放在类的私有段或公有段且没有区别。
			友元函数的调用：
				可以直接调用友元函数，不需要通过对象或指针
		友元函数 ： 
			  友元函数是可以直接访问类的私有成员的非成员函数。它是定义在类外的普通函数，它不属于任何类，但需要在类的定义中加以声明，声明时只需在友元的名称前加上关键字friend，其格式如下：
			  friend  类型 函数名(形式参数);
			  友元函数的声明可以放在类的私有部分，也可以放在公有部分，它们是没有区别的，都说明是该类的一个友元函数。一个函数可以是多个类的友元函数，只需要在各个类中分别声明。
				  友元函数的调用与一般函数的调用方式和原理一致。
		友元类 ： 
			  友元类的所有成员函数都是另一个类的友元函数，都可以访问另一个类中的隐藏信息（包括私有成员和保护成员）。       
			  当希望一个类可以存取另一个类的私有成员时，可以将该类声明为另一类的友元类。定义友元类的语句格式如下：
			  friend class 类名;
			  其中：friend和class是关键字，类名必须是程序中的一个已定义过的类。

		可以将一个类定义为另一个类的友元，但是这样的话，友元类中的所有函数成员都能访问另一个的类中的私有数据成员，这样是不安全的。最好的方法就是哪个需要访问，就设置为友元函数即可。
		当类A中的某个函数成员需要访问类B中的私有成员的时候，首先需要在类A的头文件中进行对类B的超前使用说明，这是必不可少的。其次需要在类B中将A的函数声明为友元函数。
		
2 运算符重载
	
	
3 继承
	继承格式
		class 派生类名 ：public 基类名
	继承方式
		private protected public
		单继承
		多继承
		
	继承中的构造和析构
		子类对象创建时先调用父类的构造函数
		父类构造调用后再调用子类构造
		父类构造有参数时，需要子类初始化列表中显示调用父类构造
		析构函数调用和构造函数调用相反
		
	在子类中既继承了父类，又有其他对象作为成员时的析构和构造的调用顺序
		先调用父类构造。再调用类成员构造，最后调用子类自己的构造
		析构和构造相反
		
	继承中的同名问题的处理
		如果父类子类有成员重名，子类依然会继承父类中的同名成员，在访问时，优先访问子类中的成员，就近原则。
		想要访问父类成员，需要加上类名限定符
		
	继承中的同名函数继承问题
		基类中有函数重载func_A() ,和普通函数func_B()
			--子类中重写了func_B()，父子类中的func_B（）都可以访问。就近原则，类名限定符
			--子类中重写了func_A的一个函数  在子类重载func_A后，父类中的所有func_A被隐藏，不可访问
				总结重新定义基类中的一个重载函数，在除了子类中的其他版本都被隐藏。。
				问题：父类中的重载函数是否还可以通过类名限定符来访问
		
		
	非自动继承问题
		父类中的构造和析构不可以被继承。
		operator=不可以被继承
		
		
	继承中的静态成员问题
		静态函数
			静态函数可以被子类继承
			在子类中如果重写了基类的静态方法，则父类中的静态方法被隐藏
			静态成员函数不能是虚函数（virtual function）.
		
		静态变量和函数一样。。。
	
	多继承	
		多继承格式：
			public 子类：public 父类1，public 父类2
		
		多继承容易引起二义性问题，
			对于在多个基类中定义的同名函数。在子类中访问时，引起二义性。
			解决：在子类中访问时，通过类名限定符来区分
		
		菱形继承和虚继承
			两个子类继承同一父类，又有一个孙子类同时继承两个子类。就造成菱形继承问题。
			容易产生二义性和重复继承问题
			可以通过虚基类解决
			虚基类格式：
				public A：virtual public BaseA,virtual public BaseB
		
		总结：
			多继承尽可能不要使用。会带来一系列问题
		
 
 4 多态
	静态多态
		编译阶段确定函数的调用地址，并产生代码。编译时多态，地址早绑定
	动态多态
		函数地址需要在运行时确定，属于晚绑定
		
	向上类型转换
		父类的指针指向子类的对象，通过父类指针或者引用来操作子类的对象。向上类型转换
		带来问题：
			当访问子类中继承的方法时，调用的却是父类的中的该方法，无法访问到子类中的该方法
		
	解决向上类型转换问题
		通过虚函数 virtual function 
		动态多态性通过虚函数实现
		虚函数允许子类重新定义基类中的虚函数。称为覆盖或者重写，在重写时，带上virtual关键字
		
		创建虚函数时，在声明处加上virtual关键字。定一处不加
		函数在基类中被声明为虚函数，则在所有字类中都是虚函数
		virtual 只能修饰成员函数
		构造函数不能为虚函数
	
		虚函数原理
			后续学习。。。。。
	抽象基类和纯虚函数
		抽象类
			当基类中有个 纯虚函数，则基类称为抽象类
			抽象类不可以实例化
			继承抽象类的子类必须重写该抽象类中所有的纯虚函数，否则该子类还是抽象类
		纯虚函数
			virtual int add(int i ,int j)=0;
		
		
	c++中没有接口的概念，但是可以通过纯虚函数实现类似接口的功能	
	
	虚析构函数
		virtual ~A(){cout <<"虚析构函数"endl};
		目的：	
			解决基类指针指向子类对象时的子类对象的销毁问题，。
			Base *base=new Son();
			base->~Son（）;
			
	纯虚析构
		c++中纯虚析构函数合法。
		纯虚析构函数使用时，必须要给个空实现。
		定义了纯虚函数的类为抽象类，不可实例化
		virtual ~Base ()=0;
		实现：
			Base::~Base(){};
	
	重写 重载 重定义	
		重载，同一作用域的同名函数
			1.	同一个作用域
			2.	参数个数，参数顺序，参数类型不同
			3.	和函数返回值，没有关系
			4.	const也可以作为重载条件  //do(const Teacher& t){}  do(Teacher& t)
		重定义（隐藏）
			1.	有继承
			2.	子类（派生类）重新定义父类（基类）的同名成员（非virtual函数）
			3  可以通过父类::方法的形式调用父类中被隐藏的函数
		重写（覆盖）
			1.	有继承
			2.	子类（派生类）重写父类（基类）的virtual函数
			3.	函数返回值，函数名字，函数参数，必须和基类中的虚函数一致
	
		
	指向类成员的指针
		指向成员变量的指针
			定义；
				数据类型 类名::* 指针名
				int Base::* a;
			初始化：
				int Base:: *a=& Base::a;
			
			用法
				Base base;
				base.*a;
				base->*a;
		指向成员函数的指针
			定义
				返回值类型 类名：：* 指针名（参数列表）
				int Base:: * add (int a,int b);
			初始化
				返回值类型 类名:: * 指针名（参数列表）=& 类名::非静态函数；
				int Base::* add(int a,int b)=&Base::add;
			用法
				Base base;
				(base.*add)(20,23);
				(base->*add)(23,33);
		指向静态成员的指针
			定义
				数据类型 * 指针名；
			初始化
				数据类型 * 指针名=& 基类：：变量；
				 int * a=&Base::a;
				 int * add=&Base::add;
				
			用法 
				int * p =&Base:p;
				
				void (*function_A)()=&Base::add;
				 
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		